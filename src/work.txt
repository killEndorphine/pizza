1) ставим Node +
2) Vs-code + 
3) Create-react-app + 
4) Prettier и его настройка: + 
Ctrl shift P - open user settings + 
Prettier + 
Editor: Default Formatter + 
Prettier code Formatter + 

5) верстаем каркас +
6) доливаем в него изображения +
7) наносим минимальные стили +
8) разбиваем на компоненты
а) Header
b) Categories
c) Sort
d) Popup
e) PizzaItem
f) Ставим много пицца итемов и wrap их делаем(чтобы вниз итемы прыгали)
9) в итем пиццы передаем параметры при вызове - название и цена
10) деструктуризируем пропс в итем пицце и передаем в нужные места параметры
11) используем useState в пицца итеме для увеличения счетчика пицц - тестовое (делают через редакс)
11.1) вешаем count на <i>, setCount на ссылку
12) на ссылку вешаем событие вызывающее анон ф-цию которая вызовет onClick={() => setCount(count + 1)}
13) поправили ссылку на button в пиццах
14) меняется число питсов!
15) если у нас переменная влияет на изменение отрисовки - берем useState
16) если нам нужен массив для отрисовки не изменяемый мы можем его просто хранить так: let arr = ['20см','26см','30см']
он будет создан в ф-ции - отрисует компонент 1 раз и умрет с ф-цией
17) onClick вешается на любой дом элемент
18) Categories - state Для него для активного индекса
19) мапаем массив свойств
20) проверка index и activIndex в классname для отображения стиля активной категории
21) вешаем онклик на li который сетает активный индекс
22) в событие нужно чтобы анон ф-ция вызывала нашу, а то будет бесконечный цикл отрисовок компонента
23) создадим массив питсов и засунем его в json файл в асетах в формате json
24) импортим его в арр

25) мапаем его как в категориях и передаем в пропсы свойства для отрисовки
25) мапаем li внутри питсы конкретной как в категориях но мапаем массив не из внутри ф-ции созданный а пришедший из json
26) создаем актив индекс для него и сет фцию

27) у нас есть 2ая li с меняющимися опциями
28) для нее создаем массив внутри пицца итема с теор возможными названиями опциями typeNames
29) создаем актив индекс для нее и сет фцию
30) из пропсов приходит массив индексов types = [0, 1, 2...]
31) мапаем пришедший массив types = [0, 1, 2...] создавая li 
32) внутри li обращаемся из названия к элементу теор. массива по ключу type (т.е. элем массива (0, 1, 2...)) от мапаемого пришедшего массива {typeNames[type]}
33) на событие можно повесить ф-цию если она в 1 строку, чтобы не создавать промежуточной. Пользуемся анонимной внутри события
34) мы вытягивали в питсы по 1 свойству из объекта json питс - можем передать объект целиком {...obj} в пропсах параметры должны быть точно такие же!

35) в мап массива пицц в кей передать надо не index а id! index для стат массивов, id - для динамических массивов
36) Допилим верстку попап
37) введем по клику на элемент всплывание окна выбора сортировки - см. алгоритмы
38) если там тру && (и) отражаемый элемент - то вернется нам всплывающее окно (инверсия булиан)
39) это называется условный рендеринг!
40) сделаем как с опциями пиццы - актив класснэйм, мар li
41) на ли повесим на онклик ф-цию которая 1) закрывает попап 2) сетает значение индекса ли 3) в выбранный метод соритровки уходит const sortName = list[selected] 

42) регаем проект на мокапи
43) ЗАЛИВАЕМ JSON пицц в дату проекта (items)
43.1) больше массив питсов не получам из импорта! закоментим его
44) получаем адрес обращения 'https://63735446348e947299093a2b.mockapi.io/items'
45) фетчим по адресу - ответ чейним через then и вызываем json() потом опять чейним через then и сетаем итемы вместо пустого массива
46) оборачиваем фетч запрос в useEffect. Зависимость ставим пустой массив - получим пиццы при 1ой нарисовке.
47) effect защитит от бесконечных перерисовок, т.к. у нас state обновляясь переривызовет весь свой код. мы можем получить бесконечные запросы

48) Скелетоны
49) https://skeletonreact.com/
50) рисуем скелетон согласно нашей питсе.
51) строим круги и квадраты, даем им размеры и позиционируем их.
52) копируем код слева и в отдельный компонен заносим
53) Можно сделать компонент в папке с его названием и сам файл тогда можно назвать index.jsx
54) добавим react-content-loader - для скелетонов
55) поиграем с координатами и размерами блоков скелетонов чтобы получить пиццы как у нас 
56) прикрутим класснейм пиццы блоков на скелетон. className="pizza-item"
57) теперь перепишем мар питсов
58) если идет загрузка мапаем фейк массив скелетонами иначе мапаем реальный массив питсаблоками.
59) загрузку и сет загрузку питс через useState(false)
60) теперь логику загрузки настоим

61) сначала загрузка false
62) перед фетч запросом ставим флаг через сет на тру
63) фетч выполнится
64) когда ответ придет, конвертируется и засетаются пиццы в массив - можно сетать фолс на загрузку

65) Сделаем переход в корзину с кнопки через роутер библиотеку
66) ставим react-router-dom
67) оборачиваем арр в BrouserRouter в app.js
68) сделаем страницы 3 шт КОрзина Домашняя и ничего не найдено
69) сверстаем их
70) Хедер общий у страницы
71) разместим в апп наши страницы

72) в Home отдадим часть кода апп а именно тег main
73) отдадим фетч логику и стейти с ним связанные
74) при переносе все компоненты ф-ции и модули - обновим их пути и Home вызовем в апп
75) Вызовем Home в Арр

76) Делаем блок NotFound
77) Вызовем его в апп
78) Создадим часть фаунда как компонент - он будет переиспользоваться и в других местах
79) вызовем его внутри блока NotFound
80) Там же добавим кнопку возврата например
81) сделаем css для нот фаунд через модули

82) Обернем роутами и роутсами компоненты в App
83) / - главная стр в path
83) * - не существ. стр в path
83) /card - корзина в path
84) Кинем на лого Link и to="/" сслыка на главную стр
85) На корзину Link и to="/card" - переход на стр корзины

86) мы все на флексах сделали - перейдем на гриды. нужен сайт грид генератор https://cssgrid-generator.netlify.app/
87) блок с питсами получит новую разметку вместо флексов - заменим гридами
88) блок с питсой потеряет свойства некоторые костыли.
89) повесим медиа на блок питсов для разных расширений экрана для большей адаптивности.
90) и на все остальные блоки

91) Сверстаем корзину
92) Дошли до - Всего пицц: 3 шт. Сумма заказа: 900 ₽ 
93) До конца видео идет верстка корзины - и установка скролла на начальное положение страницы

94) делаем сортировку и фильтрацию
95) нужно поднять выше на уровень из сорта и категорий индексы их массивов основавших их из useState
96) передадим хранилища индесов и ф-ции их приема от родителя детям.
97) полученные индексы вшиваем в строку запроса фетча через параметры 
98) посмотри дату чтобы категории соответсвовали!
99) desk - по убыванию параметры
100) ask - по возрастанию - чисел и букв алфавита
101) ?search=перерони&sortby=price - запрос с поиском и сортировкой

102) названия ф-ций передавая потомку от родителя можно изменить если в родителе ф-ция сетает параметр а в ребенке 
она принимает - то их можно назвать исходя из обязанностей выполняемых ими. setCategory и onClickCategory например.
103) Я не стал переименовывать ничего - а то этот хуесос запутал меня!

104) нужно изменить массив сортировок! закинуть туда доп параметры
105) ниже уже достаем св-во из объектов а не из массива, наверх отдадим объект
106) const sortName = list[selected].name - удалим
107) мы сетаем не индекс а объект. именится и useState в родителе :
const [selected, setSelected] = useState({
  name: 'популярности',
  sortProperty: 'rating',
})
108) теперь передав объект мы его спускаем ребенку
этот объект что выше - значение по умолчанию
туда будут приходить другие виды соритровок в него
их мы и спускаем ребенку
109) вытаскиваем {selected.name} в выбранный вид соритровки
110) и className={selected.sortProperty === type.sortProperty ? 'active-popup' : ''} теперь сравнения идут для класса
не по индексам а по sortProperty

111) проверка для получения всех питсов через категории:
112) подставляем наши данные в строку запроса фетч
113) в useEffect ставим зависимость и от объекта соритровки! иначе будет дудос...
114) activeIndex и selected.sortProperty - стали нашими переменными что мы в строку фетча занесли
115) как их внесли - см алгоритмы
116) нельзя получить по индексу 0 все елементы из json - там есть проверка - см также алгоритмы.

117) настроим получение итемов по asc desc
мы изменили list - см алгоритм 14
118) в useEffect появились новые проверки чтобы правильно сделать запрос и компактнее его записать см. алгоритм 15
const order = selected.sortProperty.includes('-') ? 'asc' : 'desc' - убывает или возастает параметр
const sortBy = selected.sortProperty.replace('-', '') - убирает минус из запроса с ним низя
const category = activeIndex > 0 ? `category=${activeIndex}` : '' - все питсы вернет или конкретную
119) fetch генерирует ссылку - и она уже вернет нам объекты...

120) сверстаем компонент инпут и в хедер его засунем
121) в апп вынести нужно данные из детей - из серча берем в хом отдаем уже отфильтрованное
121) прокинули стэйт из апп до сеарча
122) сделаем контролируемы инпуты
123) введем иконку крестика очищающего инпут
124) условный рендер - если в инпуте есть что - иконка показана - нету - удалена
125) {searchValue && (<svg>...</svg>)}
126) на иконку крестика онклик вешаем очистку onClick={() => setSearchValue('')}
127) флакс архитектура нужна как раз чтобы чистить инпуты!
128) мы прокидываем долго из апп в серч данные
129) нам нужен контекст... пока его не юзали лол

130) мы донесли в хоум значение из инпута
131) теперь перед мапом мы можем повесить на массив фильтр - см алгоритм 17
132) toLowerCase - ровняет регистры у нас значения введенного и имени пришедшего с бека
133) includes - делает сравнение 2х строк 
134) фильтр вернет в массив элементы прошедшие условие.
135) здесь поиск идет без запроса на бекэнд. Вроде как надо подругому и это учебный пример , но хз...
136) такой способ подходит для статичного массива!

137) теперь запрос сделаем через бэк - так как у нас может быть 1000 итемов а рендерим мы 10!
138) мы в юзеффект также вшиваем в строку запроса наше значение с инпута см. алгоритм 18
139) мы также удалили старый способ через фильтр
140) мокапи плохо работает сразу с 3мя способами получения массива - он не сортирует после фильтрации...
141) это не наша ошибка а его - надо использовать норм бэк

142) пагинация
143) установим react-pagination
144) сверстаем пагинацию
145) c помощья scss - см алгоритм 19

146) изменяем строку запроса питс - появляются новые параметры page и limit
147) у нас не возвращается кол-во питс и из бека...
148) мы захадкодим в хоме текущую стр в usestate
149) кол-во длементов просто сделаем 4
150) вообще делается тоже при приходе с бека и расчета
151) в пагинацию оправляем ф-цию которая прнимает индекс
152) с элемента пагинации снимаем в онклик эвент и отдаем пришедшей ф-ции индекс через onPageChange={(e) => onChangePage(e.selected + 1)}
153) см алгоритмы
154) далее юзэффект видит изменение текущей стр и делает новый запрос за данными

155) контекст:
156) Создадим объект контекста и экспортируем его
156.1) Создание объекта идет в том месте где лежат данные что мы спускаем
157) обернем в него наше все приложение (или часть приложения нижестоящего)
158) в вэлью отдадим ссылки на наши переменные от useState
159) в потомке вызовем useContext передадим в него наш экспортированный объект
160) все это присвоем через деструктуризацию в потомке.
161) удалим из пропсов старые ссылки
162) useContext слушает наш контекст и сразу перерисовывает детей

163) Redux:
164) фильтрацию перенесем в Redux
165) npm install @reduxjs/toolkit
166) npm install react-redux
167) делается отдельная папка с redux там стор.js в нем создаем хранилище - см 23 алгоритм
168) импортируем в апп 
169) обернем провайдером приложение
170) передадим в провайдер стор
171) создадим слайс
172) смотри алгоритмы 23-25
173) делаем начальное состояние - переносим его из апп
174) делаем слайс - в нем имя, начальлное состояние и ф-ции редюсеры
175) редюсеры получают данные из актиона райлоада
176) и изменяют начальное состояние
177) экспортируем эти ф-ции и наш слайс - см алгоритм
178) слайс подключаем в стор
179) в хоум импортируем наши редюсеры useDispatch и useSelector 
180) диспатч принимает данные и делает объект экшен
181) селектор достает данные из слайса и отдает их потомкам

182) сортировку перенесем в редакс - также как с п163 по п181(не все пункты!)

183) axios
184) npm install axios
185) фетч запрос меняем на аксиос
186) там json() не нужен. можем сразу поучить res.data
187) см алгоритм 28

188) useRef:
189) создаем ссылку в переменной на useRef, вешаем ее на нужый для фокуса элемент через ref параметр
190) на закрывающий элемент вешаем ф-цию что делает фокус на нашу ссылку (и очищает введеные значения)
191) см алгоритм 29

192) Debouce - задержка отправки из инпута запроса на бекэнд
193) Lodash - библиотека полезных методов для js объектов
194) npm install lodash.debounce мы взяли число часть!

195) он делает 2 стейта на серч - локальный и у родителя - мне это не нравится.
196) deboune отложим пока

197) он вынес в фильтр слайс пагинацию
198) Все стейты переносим из хоум в хоум слайс

199) попап
200) сначала сделали попап на все окно - см алгоритм 30
201) в сорт компоненте вешает useEffect - обращаемся к боди через document.body в нем
202) вешаем событиеклик document.body.addEventListener('click')
202) отдаем событию ф-цию которая будет создана в useEffect
203) в ней мы смотрим путь эвента 
204) если есть путь до нашего элемента попап - ничего не делаем
205) если мы нажали вне нашего попап - выполняет setOpen(false) - закрывая попап path.includes(sortRef.current) - проверка для закытия\
206) и также делаем анмаунт - удаляем ф-цию через ретурн и анонф-цию с ремувлисенер
206.1) также мы предварительно повесили useRef на наше попап окно.

207) Корзина и редакс... - 31 алгоритм
208) при нажатии на кнопку в питсаитеме - формируем объект питсы и отдаем через диспатч ф-ции аддитем
209) ф-ция аддитем в слайсе корзины принимает экшн и стейт
210) Получим объект из массива через файнд по условию что id из пришедшего объекта = id из стейта
211) делаем проверку если полученный объект с таким же id уже есть в стейте - объекту
присваиваем в св-во каунт++
212) иначе присваиваем в итемс с деструктуризацией наш полученый объект и новое свойство каунт = 1
213) мы создали 2 вариант или мы сетаем новую питсу или у уже имеющейся счетчик питс повышаем на 1
214) в инит стейте есть св-во общее колво питс
215) мы берем в эту переменныю присвоим результат от редюса всего массива питс где к 0 мы присваиваем
текущие каунты - редюс бежит по всем объектам и в аккамуляторе сумм накапливает все значения массива.
216) теперь мы посчитаем общую цену всех питс массива здесь же
217) мы берем в эту переменныю присвоим результат от редюса всего массива питс где к 0 мы присваиваем
текущие каунты * прайс - редюс бежит по всем объектам и в аккамуляторе сумм накапливает все значения массива.

218) в хедер выносим общую цену и колво питс
219) через useSelector в питсеитеме мы выносим массив питс и его файндим по id чтобы id было равно id итема из массива
220) делаем проверку - если объект не найден - принимаем ноль или объект.каунт
221) делаем условную отрисовку в кнопку питсаитема

222) отдаем массив питс, кол-во питс и сумму цен из картСлайса в корзину
223) мапаем массив и отдаем в элемент рендера итем
224) прокидываем пропсы в нужные места
225) через диспатч достаем аддитем и вешаем на кнопку + в аддитем отдаем объект из св-ва id
226) у нас есть уже объект в итемс поэтому пройдя проверку в редаксе объект пиццы каунт увеличися на 1

227) minusItem: - 32 алгоритм
228) вешаем фцию через dispatch на кнопку - и передаем id
229) в ф-ции принимая id ищем в массиве этот элемент через find условие что id === action.id
230) полученный элемент его каунт делаем -- если там каунт > 1 - иначе делаем фильтр массива
state.items = state.items.filter((obj) => obj !== findItem)
231) пересчитываем кол-во питс и общую сумму по алгоритму из аддитем 

232) removeItem: - 33 алгоритм
233) отдаем ф-цию в картитем
234) через диспатч и онклик отдаем ей id
235) предварительно делаем проверку на уверенность удаления итема
236) в редаксе делаем фильтр на пришедший id (item.id !== id) и в итемс все это сетаем
237) пересчитываем тотал и тоталпрайс как выше делали

238) clearItems: - 34 алгоритм
239) на кнопку корзины вешаем через диспатч и клик ф-цию clearItems и вызываем ее ничего не передавая
240) в редаксе все обнуляем - итемс тотал тоталпрайс

241) делаем условную отрисовку - 35 алгоритм
242) если тоталпайс ноль - рисуем пустую корзину или ту которая содержит товары

243) async await try catch
244) на аксиос вешаем авэйт а фцию в которой он лежит делаем асинк
245) мы превратили асинхронный код в синхронный!
246) засовываем все в трай кеч файнали
247) Теперь у нас при ошибке приложение не крашнется!
248) см алгоритм 36

249) createAsyncThunk: - см 37 алгоритм
250) создаем санку через ф-цию редакса и присваиваем переменной.
251) внутри нее будет создана анон ф-ция которая будет асинком - принимает параметры что ей отдадим а хоме
252) экспортируем ее туда и несем в хом. Там отдав параметры вызываем.
253) внутри нее идет аксиос запрос с полученными параметрами через авайт
254) по итогу получив данные ретурним их
255) на основе нашей санки делаем экстраредюсер
256) там 3 стадии с данными.
257) 1 - загрузка данных - мы можем засетать лоадинг и очистить массив данных
258) 2 - данные успешно загрузились - мы их сетаем в этом экстаредюсере.
259) 3 - произошла ошибка - мы чистим массив данных и сетаем еррор
260) на основании этого рисуется или стр с еррор или скелетоны или страница с полученными данными

261) selector
262) searchValue перенесли в хоумслайс - прокинули назад в сеарч и хоум
263) удалили контекст
264) все вызовы внутри useSelector переносим в редакс и делаем их как функции __Selector и прокидываем там
где до этого вызывали - мы упростили код этим и избавились от DRY

265) useLocation помогает скрывать элементы
266) он читает путь ссылки и по нему можно делать проверку - удалять или оставлять элемент на странице

267) useParams и - доверстать пиццастраницу - сделать слайс и всю логику в него унести
268) сделать скелетон на питсастраницу
268) useParams - при создании страницы питсы использованы все предыдущие алгоритмы
269) мы на картинку вешаем линк который создает путь в строке запроса сервера - <Link to={`/items/${id}`}>
270) id берется у объекта создавшего питсу.
271) в апп роут следит за путем и рисует компонент питсапэйдж - path="/items/:id"
272) в этом компоненте(питсапэйдж) через useParams вытаскивается id и его передаем в редакс на запрос
273) пока идет запрос - мы видим скелетон!

274) layouts - см алгоритм 41 - там изи! мы вынесли роутеры и зарефакторили




https://www.youtube.com/watch?v=06bh14iY3dA&list=PL0FGkDGJQjJG9eI85xM1_iLIf6BcEdaNl&index=20

time: 0:39:51