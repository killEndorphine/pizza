1) ставим Node +
2) Vs-code + 
3) Create-react-app + 
4) Prettier и его настройка: + 
Ctrl shift P - open user settings + 
Prettier + 
Editor: Default Formatter + 
Prettier code Formatter + 

5) верстаем каркас +
6) доливаем в него изображения +
7) наносим минимальные стили +
8) разбиваем на компоненты
а) Header
b) Categories
c) Sort
d) Popup
e) PizzaItem
f) Ставим много пицца итемов и wrap их делаем(чтобы вниз итемы прыгали)
9) в итем пиццы передаем параметры при вызове - название и цена
10) деструктуризируем пропс в итем пицце и передаем в нужные места параметры
11) используем useState в пицца итеме для увеличения счетчика пицц - тестовое (делают через редакс)
11.1) вешаем count на <i>, setCount на ссылку
12) на ссылку вешаем событие вызывающее анон ф-цию которая вызовет onClick={() => setCount(count + 1)}
13) поправили ссылку на button в пиццах
14) меняется число питсов!
15) если у нас переменная влияет на изменение отрисовки - берем useState
16) если нам нужен массив для отрисовки не изменяемый мы можем его просто хранить так: let arr = ['20см','26см','30см']
он будет создан в ф-ции - отрисует компонент 1 раз и умрет с ф-цией
17) onClick вешается на любой дом элемент
18) Categories - state Для него для активного индекса
19) мапаем массив свойств
20) проверка index и activIndex в классname для отображения стиля активной категории
21) вешаем онклик на li который сетает активный индекс
22) в событие нужно чтобы анон ф-ция вызывала нашу, а то будет бесконечный цикл отрисовок компонента
23) создадим массив питсов и засунем его в json файл в асетах в формате json
24) импортим его в арр

25) мапаем его как в категориях и передаем в пропсы свойства для отрисовки
25) мапаем li внутри питсы конкретной как в категориях но мапаем массив не из внутри ф-ции созданный а пришедший из json
26) создаем актив индекс для него и сет фцию

27) у нас есть 2ая li с меняющимися опциями
28) для нее создаем массив внутри пицца итема с теор возможными названиями опциями typeNames
29) создаем актив индекс для нее и сет фцию
30) из пропсов приходит массив индексов types = [0, 1, 2...]
31) мапаем пришедший массив types = [0, 1, 2...] создавая li 
32) внутри li обращаемся из названия к элементу теор. массива по ключу type (т.е. элем массива (0, 1, 2...)) от мапаемого пришедшего массива {typeNames[type]}
33) на событие можно повесить ф-цию если она в 1 строку, чтобы не создавать промежуточной. Пользуемся анонимной внутри события
34) мы вытягивали в питсы по 1 свойству из объекта json питс - можем передать объект целиком {...obj} в пропсах параметры должны быть точно такие же!

35) в мап массива пицц в кей передать надо не index а id! index для стат массивов, id - для динамических массивов
36) Допилим верстку попап
37) введем по клику на элемент всплывание окна выбора сортировки - см. алгоритмы
38) если там тру && (и) отражаемый элемент - то вернется нам всплывающее окно (инверсия булиан)
39) это называется условный рендеринг!
40) сделаем как с опциями пиццы - актив класснэйм, мар li
41) на ли повесим на онклик ф-цию которая 1) закрывает попап 2) сетает значение индекса ли 3) в выбранный метод соритровки уходит const sortName = list[selected] 

42) регаем проект на мокапи
43) ЗАЛИВАЕМ JSON пицц в дату проекта (items)
43.1) больше массив питсов не получам из импорта! закоментим его
44) получаем адрес обращения 'https://63735446348e947299093a2b.mockapi.io/items'
45) фетчим по адресу - ответ чейним через then и вызываем json() потом опять чейним через then и сетаем итемы вместо пустого массива
46) оборачиваем фетч запрос в useEffect. Зависимость ставим пустой массив - получим пиццы при 1ой нарисовке.
47) effect защитит от бесконечных перерисовок, т.к. у нас state обновляясь переривызовет весь свой код. мы можем получить бесконечные запросы

48) Скелетоны
49) https://skeletonreact.com/
50) рисуем скелетон согласно нашей питсе.
51) строим круги и квадраты, даем им размеры и позиционируем их.
52) копируем код слева и в отдельный компонен заносим
53) Можно сделать компонент в папке с его названием и сам файл тогда можно назвать index.jsx
54) добавим react-content-loader - для скелетонов
55) поиграем с координатами и размерами блоков скелетонов чтобы получить пиццы как у нас 
56) прикрутим класснейм пиццы блоков на скелетон. className="pizza-item"
57) теперь перепишем мар питсов
58) если идет загрузка мапаем фейк массив скелетонами иначе мапаем реальный массив питсаблоками.
59) загрузку и сет загрузку питс через useState(false)
60) теперь логику загрузки настоим

61) сначала загрузка false
62) перед фетч запросом ставим флаг через сет на тру
63) фетч выполнится
64) когда ответ придет, конвертируется и засетаются пиццы в массив - можно сетать фолс на загрузку






https://www.youtube.com/watch?v=eUt-M-YRjyg&list=PL0FGkDGJQjJG9eI85xM1_iLIf6BcEdaNl&index=8

time: 0:29:30