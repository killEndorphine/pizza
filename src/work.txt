1) ставим Node +
2) Vs-code + 
3) Create-react-app + 
4) Prettier и его настройка: + 
Ctrl shift P - open user settings + 
Prettier + 
Editor: Default Formatter + 
Prettier code Formatter + 

5) верстаем каркас +
6) доливаем в него изображения +
7) наносим минимальные стили +
8) разбиваем на компоненты
а) Header
b) Categories
c) Sort
d) Popup
e) PizzaItem
f) Ставим много пицца итемов и wrap их делаем(чтобы вниз итемы прыгали)
9) в итем пиццы передаем параметры при вызове - название и цена
10) деструктуризируем пропс в итем пицце и передаем в нужные места параметры
11) используем useState в пицца итеме для увеличения счетчика пицц - тестовое (делают через редакс)
11.1) вешаем count на <i>, setCount на ссылку
12) на ссылку вешаем событие вызывающее анон ф-цию которая вызовет onClick={() => setCount(count + 1)}
13) поправили ссылку на button в пиццах
14) меняется число питсов!
15) если у нас переменная влияет на изменение отрисовки - берем useState
16) если нам нужен массив для отрисовки не изменяемый мы можем его просто хранить так: let arr = ['20см','26см','30см']
он будет создан в ф-ции - отрисует компонент 1 раз и умрет с ф-цией
17) onClick вешается на любой дом элемент
18) Categories - state Для него для активного индекса
19) мапаем массив свойств
20) проверка index и activIndex в классname для отображения стиля активной категории
21) вешаем онклик на li который сетает активный индекс
22) в событие нужно чтобы анон ф-ция вызывала нашу, а то будет бесконечный цикл отрисовок компонента
23) создадим массив питсов и засунем его в json файл в асетах в формате json
24) импортим его в арр

25) мапаем его как в категориях и передаем в пропсы свойства для отрисовки
25) мапаем li внутри питсы конкретной как в категориях но мапаем массив не из внутри ф-ции созданный а пришедший из json
26) создаем актив индекс для него и сет фцию

27) у нас есть 2ая li с меняющимися опциями
28) для нее создаем массив внутри пицца итема с теор возможными названиями опциями typeNames
29) создаем актив индекс для нее и сет фцию
30) из пропсов приходит массив индексов types = [0, 1, 2...]
31) мапаем пришедший массив types = [0, 1, 2...] создавая li 
32) внутри li обращаемся из названия к элементу теор. массива по ключу type (т.е. элем массива (0, 1, 2...)) от мапаемого пришедшего массива {typeNames[type]}
33) на событие можно повесить ф-цию если она в 1 строку, чтобы не создавать промежуточной. Пользуемся анонимной внутри события
34) мы вытягивали в питсы по 1 свойству из объекта json питс - можем передать объект целиком {...obj} в пропсах параметры должны быть точно такие же!

35) в мап массива пицц в кей передать надо не index а id! index для стат массивов, id - для динамических массивов
36) Допилим верстку попап
37) введем по клику на элемент всплывание окна выбора сортировки - см. алгоритмы
38) если там тру && (и) отражаемый элемент - то вернется нам всплывающее окно (инверсия булиан)
39) это называется условный рендеринг!
40) сделаем как с опциями пиццы - актив класснэйм, мар li
41) на ли повесим на онклик ф-цию которая 1) закрывает попап 2) сетает значение индекса ли 3) в выбранный метод соритровки уходит const sortName = list[selected] 

42) регаем проект на мокапи
43) ЗАЛИВАЕМ JSON пицц в дату проекта (items)
43.1) больше массив питсов не получам из импорта! закоментим его
44) получаем адрес обращения 'https://63735446348e947299093a2b.mockapi.io/items'
45) фетчим по адресу - ответ чейним через then и вызываем json() потом опять чейним через then и сетаем итемы вместо пустого массива
46) оборачиваем фетч запрос в useEffect. Зависимость ставим пустой массив - получим пиццы при 1ой нарисовке.
47) effect защитит от бесконечных перерисовок, т.к. у нас state обновляясь переривызовет весь свой код. мы можем получить бесконечные запросы

48) Скелетоны
49) https://skeletonreact.com/
50) рисуем скелетон согласно нашей питсе.
51) строим круги и квадраты, даем им размеры и позиционируем их.
52) копируем код слева и в отдельный компонен заносим
53) Можно сделать компонент в папке с его названием и сам файл тогда можно назвать index.jsx
54) добавим react-content-loader - для скелетонов
55) поиграем с координатами и размерами блоков скелетонов чтобы получить пиццы как у нас 
56) прикрутим класснейм пиццы блоков на скелетон. className="pizza-item"
57) теперь перепишем мар питсов
58) если идет загрузка мапаем фейк массив скелетонами иначе мапаем реальный массив питсаблоками.
59) загрузку и сет загрузку питс через useState(false)
60) теперь логику загрузки настоим

61) сначала загрузка false
62) перед фетч запросом ставим флаг через сет на тру
63) фетч выполнится
64) когда ответ придет, конвертируется и засетаются пиццы в массив - можно сетать фолс на загрузку

65) Сделаем переход в корзину с кнопки через роутер библиотеку
66) ставим react-router-dom
67) оборачиваем арр в BrouserRouter в app.js
68) сделаем страницы 3 шт КОрзина Домашняя и ничего не найдено
69) сверстаем их
70) Хедер общий у страницы
71) разместим в апп наши страницы

72) в Home отдадим часть кода апп а именно тег main
73) отдадим фетч логику и стейти с ним связанные
74) при переносе все компоненты ф-ции и модули - обновим их пути и Home вызовем в апп
75) Вызовем Home в Арр

76) Делаем блок NotFound
77) Вызовем его в апп
78) Создадим часть фаунда как компонент - он будет переиспользоваться и в других местах
79) вызовем его внутри блока NotFound
80) Там же добавим кнопку возврата например
81) сделаем css для нот фаунд через модули

82) Обернем роутами и роутсами компоненты в App
83) / - главная стр в path
83) * - не существ. стр в path
83) /card - корзина в path
84) Кинем на лого Link и to="/" сслыка на главную стр
85) На корзину Link и to="/card" - переход на стр корзины

86) мы все на флексах сделали - перейдем на гриды. нужен сайт грид генератор https://cssgrid-generator.netlify.app/
87) блок с питсами получит новую разметку вместо флексов - заменим гридами
88) блок с питсой потеряет свойства некоторые костыли.
89) повесим медиа на блок питсов для разных расширений экрана для большей адаптивности.
90) и на все остальные блоки

91) Сверстаем корзину
92) Дошли до - Всего пицц: 3 шт. Сумма заказа: 900 ₽ 
93) До конца видео идет верстка корзины - и установка скролла на начальное положение страницы

94) делаем сортировку и фильтрацию
95) нужно поднять выше на уровень из сорта и категорий индексы их массивов основавших их из useState
96) передадим хранилища индесов и ф-ции их приема от родителя детям.
97) полученные индексы вшиваем в строку запроса фетча через параметры 
98) посмотри дату чтобы категории соответсвовали!
99) desk - по убыванию параметры
100) ask - по возрастанию - чисел и букв алфавита
101) ?search=перерони&sortby=price - запрос с поиском и сортировкой

102) названия ф-ций передавая потомку от родителя можно изменить если в родителе ф-ция сетает параметр а в ребенке 
она принимает - то их можно назвать исходя из обязанностей выполняемых ими. setCategory и onClickCategory например.
103) Я не стал переименовывать ничего - а то этот хуесос запутал меня!

104) нужно изменить массив сортировок! закинуть туда доп параметры
105) ниже уже достаем св-во из объектов а не из массива, наверх отдадим объект
106) const sortName = list[selected].name - удалим
107) мы сетаем не индекс а объект. именится и useState в родителе :
const [selected, setSelected] = useState({
  name: 'популярности',
  sortProperty: 'rating',
})
108) теперь передав объект мы его спускаем ребенку
этот объект что выше - значение по умолчанию
туда будут приходить другие виды соритровок в него
их мы и спускаем ребенку
109) вытаскиваем {selected.name} в выбранный вид соритровки
110) и className={selected.sortProperty === type.sortProperty ? 'active-popup' : ''} теперь сравнения идут для класса
не по индексам а по sortProperty

111) проверка для получения всех питсов через категории:
112) подставляем наши данные в строку запроса фетч
113) в useEffect ставим зависимость и от объекта соритровки! иначе будет дудос...
114) activeIndex и selected.sortProperty - стали нашими переменными что мы в строку фетча занесли
115) как их внесли - см алгоритмы
116) нельзя получить по индексу 0 все елементы из json - там есть проверка - см также алгоритмы.

117) настроим получение итемов по asc desc
мы изменили list - см алгоритм 14
118) в useEffect появились новые проверки чтобы правильно сделать запрос и компактнее его записать см. алгоритм 15
const order = selected.sortProperty.includes('-') ? 'asc' : 'desc' - убывает или возастает параметр
const sortBy = selected.sortProperty.replace('-', '') - убирает минус из запроса с ним низя
const category = activeIndex > 0 ? `category=${activeIndex}` : '' - все питсы вернет или конкретную
119) fetch генерирует ссылку - и она уже вернет нам объекты...

120) сверстаем компонент инпут и в хедер его засунем
121) в апп вынести нужно данные из детей - из серча берем в хом отдаем уже отфильтрованное
121) прокинули стэйт из апп до сеарча
122) сделаем контролируемы инпуты
123) введем иконку крестика очищающего инпут
124) условный рендер - если в инпуте есть что - иконка показана - нету - удалена
125) {searchValue && (<svg>...</svg>)}
126) на иконку крестика онклик вешаем очистку onClick={() => setSearchValue('')}
127) флакс архитектура нужна как раз чтобы чистить инпуты!
128) мы прокидываем долго из апп в серч данные
129) нам нужен контекст... пока его не юзали лол

130) мы донесли в хоум значение из инпута
131) теперь перед мапом мы можем повесить на массив фильтр - см алгоритм 17
132) toLowerCase - ровняет регистры у нас значения введенного и имени пришедшего с бека
133) includes - делает сравнение 2х строк 
134) фильтр вернет в массив элементы прошедшие условие.
135) здесь поиск идет без запроса на бекэнд. Вроде как надо подругому и это учебный пример , но хз...
136) такой способ подходит для статичного массива!

137) теперь запрос сделаем через бэк - так как у нас может быть 1000 итемов а рендерим мы 10!
138) мы в юзеффект также вшиваем в строку запроса наше значение с инпута см. алгоритм 18
139) мы также удалили старый способ через фильтр
140) мокапи плохо работает сразу с 3мя способами получения массива - он не сортирует после фильтрации...
141) это не наша ошибка а его - надо использовать норм бэк

142) пагинация
143) установим react-pagination
144) сверстаем пагинацию
145) c помощья scss - см алгоритм 19

146) изменяем строку запроса питс - появляются новые параметры page и limit
147) у нас не возвращается кол-во питс и из бека...
148) мы захадкодим в хоме текущую стр в usestate
149) кол-во длементов просто сделаем 4
150) вообще делается тоже при приходе с бека и расчета
151) в пагинацию оправляем ф-цию которая прнимает индекс
152) с элемента пагинации снимаем в онклик эвент и отдаем пришедшей ф-ции индекс через onPageChange={(e) => onChangePage(e.selected + 1)}
153) см алгоритмы
154) далее юзэффект видит изменение текущей стр и делает новый запрос за данными

155) контекст:
156) Создадим объект контекста и экспортируем его
156.1) Создание объекта идет в том месте где лежат данные что мы спускаем
157) обернем в него наше все приложение (или часть приложения нижестоящего)
158) в вэлью отдадим ссылки на наши переменные от useState
159) в потомке вызовем useContext передадим в него наш экспортированный объект
160) все это присвоем через деструктуризацию в потомке.
161) удалим из пропсов старые ссылки
162) useContext слушает наш контекст и сразу перерисовывает детей

163) Redux:
164) фильтрацию перенесем в Redux
165) npm install @reduxjs/toolkit
166) npm install react-redux
167) делается отдельная папка с redux там стор.js в нем создаем хранилище - см 23 алгоритм
168) импортируем в апп 
169) обернем провайдером приложение
170) передадим в провайдер стор
171) создадим слайс
172) смотри алгоритмы 23-25
173) делаем начальное состояние - переносим его из апп
174) делаем слайс - в нем имя, начальлное состояние и ф-ции редюсеры
175) редюсеры получают данные из актиона райлоада
176) и изменяют начальное состояние
177) экспортируем эти ф-ции и наш слайс - см алгоритм
178) слайс подключаем в стор
179) в хоум импортируем наши редюсеры useDispatch и useSelector 
180) диспатч принимает данные и делает объект экшен
181) селектор достает данные из слайса и отдает их потомкам



https://www.youtube.com/watch?v=h1Q2V2Ek0EQ&list=PL0FGkDGJQjJG9eI85xM1_iLIf6BcEdaNl&index=14

time: 0:46:56